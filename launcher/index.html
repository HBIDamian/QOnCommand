<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
    <title>QOnCommand</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="assets/icon.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="assets/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="assets/favicon-16x16.png">
    
    <!-- CSS -->
    <link rel="stylesheet" href="assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="assets/css/fonts.css">
    <link rel="stylesheet" href="assets/css/app.css">
</head>
<body class="d-flex flex-column min-vh-100">
    <div id="loading-overlay" class="position-fixed top-0 start-0 w-100 h-100 d-flex align-items-center justify-content-center" style="z-index: 1050;">
        <div class="text-center">
            <div class="spinner-border text-primary" role="status"></div>
            <div class="mt-3 fw-semibold">Loading QOnCommand...</div>
        </div>
    </div>

    <div class="main-container flex-grow-1 d-flex justify-content-center py-4 py-md-5" style="overflow-y: auto;">
        <div class="w-100" style="max-width: 420px;">
            <div class="glass-card p-4 p-md-5">
                <header class="text-center mb-4">
                    <div class="mb-3">
                        <img src="assets/icon.svg" alt="QOnCommand Logo" style="width: 64px; height: 64px; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.2));">
                    </div>
                    <h1 class="display-5 fw-bold text-gradient mb-2">QOnCommand</h1>
                    <p class="text-soft small mb-0">Professional QLab Remote Control</p>
                </header>

                <section class="launcher-section">
                    <div class="glass-panel">
                        <div class="d-flex align-items-center justify-content-between mb-2">
                            <span class="info-card-title">Local IP Address</span>
                            <button id="refresh-ip-btn" class="btn btn-outline-glass btn-sm fw-semibold">â†» Refresh</button>
                        </div>
                        <div id="local-ip" class="info-card-value text-center">Loading...</div>
                    </div>
                </section>

                <section class="launcher-section">
                    <div class="glass-panel">
                        <div class="d-flex align-items-center justify-content-between">
                            <div class="d-flex align-items-center gap-2">
                                <span id="status-indicator" class="status-dot status-stopped"></span>
                                <span id="status-text" class="fw-semibold">Server Stopped</span>
                            </div>
                            <div id="server-url" class="small text-soft text-end"></div>
                        </div>
                    </div>
                </section>

                <section class="launcher-section">
                    <label for="port-input" class="form-label text-soft fw-semibold">Port</label>
                    <input type="number" id="port-input" min="1024" max="65535" value="7522" class="form-control form-control-glass" placeholder="7522">
                </section>

                <section class="launcher-section">
                    <div class="glass-panel d-flex align-items-center justify-content-between gap-3">
                        <div>
                            <div class="fw-semibold">Open Browser on Start</div>
                            <div class="small text-soft">Automatically open web interface when server starts</div>
                        </div>
                        <div class="form-check form-switch form-switch-glass m-0">
                            <input type="checkbox" id="browser-toggle" class="form-check-input">
                        </div>
                    </div>
                </section>

                <section class="launcher-section">
                    <div class="glass-panel d-flex align-items-center justify-content-between gap-3">
                        <div>
                            <div class="fw-semibold">Start Server on Launcher Load</div>
                            <div class="small text-soft">Automatically start server when launcher opens</div>
                        </div>
                        <div class="form-check form-switch form-switch-glass m-0">
                            <input type="checkbox" id="autostart-toggle" class="form-check-input">
                        </div>
                    </div>
                </section>

                <section class="launcher-section">
                    <button id="toggle-server-btn" class="btn btn-gradient-primary btn-modern w-100" disabled>
                        <span id="toggle-btn-text">Start Server</span>
                    </button>
                </section>

                <section id="web-interface-section" class="launcher-section hidden">
                    <button id="open-web-btn" class="btn btn-outline-glass btn-modern w-100">Open Web Interface</button>
                </section>

                <section id="logs-section" class="launcher-section hidden">
                    <div class="glass-panel logs-card">
                        <div class="small text-soft text-uppercase fw-semibold mb-2">Status</div>
                        <textarea id="status-log" class="form-control form-control-glass status-textarea" readonly></textarea>
                    </div>
                </section>

                <div class="launcher-footer text-center mt-4 pt-3" style="border-top: 1px solid rgba(148, 163, 184, 0.25);">
                    <p>Figure 53Â® and QLabÂ® are registered trademarks of Figure 53, LLC.</p>
                    <p>QOnCommand is not affiliated with Figure 53, LLC.</p>
                </div>
            </div>
        </div>
    </div>

    <script src="assets/js/bootstrap.bundle.min.js"></script>
    <script>
        class QOnCommandLauncher {
            constructor() {
                this.serverRunning = false;
                this.localIP = 'Loading...';
                this.currentPort = 7522;
                this.initializationComplete = false;
                this.shouldAutoStart = false; // Explicitly default to false
                
                this.initializeElements();
                this.bindEvents();
                this.initialize();
            }

            async initialize() {
                const startTime = Date.now();
                const minLoadingTime = 800; // Minimum loading time in ms for better UX
                
                try {
                    // Initialize all components
                    await this.loadSettings();
                    await this.getLocalIP();
                    await this.updateServerStatus();
                    
                    // Check for auto-start after server status is known
                    this.checkAutoStart();
                    
                    // Set up periodic status updates
                    setInterval(() => this.updateServerStatus(), 2000);
                    
                    // Ensure minimum loading time for smooth experience
                    const elapsed = Date.now() - startTime;
                    const remainingTime = Math.max(0, minLoadingTime - elapsed);
                    
                    setTimeout(() => {
                        // Mark initialization as complete and show the UI
                        this.initializationComplete = true;
                        this.showLauncher();
                    }, remainingTime);
                    
                } catch (error) {
                    console.error('Initialization error:', error);
                    // Show launcher even if there are errors, after minimum time
                    const elapsed = Date.now() - startTime;
                    const remainingTime = Math.max(0, minLoadingTime - elapsed);
                    
                    setTimeout(() => {
                        this.showLauncher();
                    }, remainingTime);
                }
            }

            showLauncher() {
                console.log('showLauncher called');
                // Hide loading overlay
                const loadingOverlay = document.getElementById('loading-overlay');
                if (loadingOverlay) {
                    console.log('Hiding loading overlay');
                    loadingOverlay.style.opacity = '0';
                    loadingOverlay.style.pointerEvents = 'none';
                    setTimeout(() => {
                        loadingOverlay.style.display = 'none';
                        loadingOverlay.remove(); // Completely remove it from DOM
                        console.log('Loading overlay removed');
                    }, 300);
                }
                
                // Add loaded class to body to trigger fade-in
                document.body.classList.add('loaded');
                console.log('Launcher should now be interactive');
            }

            checkAutoStart() {
                console.log('=== AUTO-START CHECK ===');
                console.log('shouldAutoStart:', this.shouldAutoStart, '(type:', typeof this.shouldAutoStart, ')');
                console.log('serverRunning:', this.serverRunning);
                console.log('autostartToggle.checked:', this.autostartToggle.checked);
                
                // EMERGENCY KILL SWITCH - Remove this line once working
                console.log('ðŸš« AUTO-START TEMPORARILY DISABLED FOR DEBUGGING');
                this.addLogEntry({ message: 'Auto-start temporarily disabled for debugging', level: 'info' });
                return;
                
                // Triple check - use toggle state as backup
                const shouldStart = (this.shouldAutoStart === true) && (this.autostartToggle.checked === true) && (!this.serverRunning);
                console.log('Final decision - shouldStart:', shouldStart);
                
                if (shouldStart) {
                    console.log('âœ“ Auto-starting server...');
                    setTimeout(() => {
                        this.addLogEntry({ message: 'Auto-starting server...', level: 'info' });
                        this.startServer();
                    }, 1000);
                } else {
                    console.log('âœ— Auto-start not triggered');
                    this.addLogEntry({ message: 'Auto-start disabled - server not started', level: 'info' });
                }
                console.log('=== END AUTO-START CHECK ===');
            }

            initializeElements() {
                this.toggleBtn = document.getElementById('toggle-server-btn');
                this.toggleBtnText = document.getElementById('toggle-btn-text');
                this.openWebBtn = document.getElementById('open-web-btn');
                this.statusIndicator = document.getElementById('status-indicator');
                this.statusText = document.getElementById('status-text');
                this.serverUrl = document.getElementById('server-url');
                this.portInput = document.getElementById('port-input');
                this.localIpDisplay = document.getElementById('local-ip');
                this.refreshIpBtn = document.getElementById('refresh-ip-btn');
                this.browserToggle = document.getElementById('browser-toggle');
                this.autostartToggle = document.getElementById('autostart-toggle');
                this.webInterfaceSection = document.getElementById('web-interface-section');
                this.logsSection = document.getElementById('logs-section');
                this.statusLog = document.getElementById('status-log');
            }

            bindEvents() {
                this.toggleBtn.addEventListener('click', () => this.toggleServer());
                this.openWebBtn.addEventListener('click', () => this.openWebInterface());
                this.portInput.addEventListener('change', () => this.saveSettings());
                this.refreshIpBtn.addEventListener('click', () => this.refreshLocalIP());
                this.browserToggle.addEventListener('change', () => this.saveSettings());
                this.autostartToggle.addEventListener('change', () => this.saveSettings());

                // Server status listener
                if (window.electronAPI) {
                    window.electronAPI.onServerStatus((event, data) => {
                        this.handleServerStatusUpdate(data);
                    });

                    window.electronAPI.onServerLog((event, data) => {
                        this.addLogEntry(data);
                    });
                }
            }

            async loadSettings() {
                if (window.electronAPI) {
                    try {
                        const settings = await window.electronAPI.getSettings();
                        console.log('Loaded settings:', settings);
                        console.log('Raw autoStart value:', settings.autoStart, 'Type:', typeof settings.autoStart);
                        
                        this.currentPort = settings.port || 7522;
                        this.portInput.value = this.currentPort;
                        this.browserToggle.checked = Boolean(settings.openBrowserOnStart);
                        this.autostartToggle.checked = Boolean(settings.autoStart);
                        this.updateServerUrl();
                        
                        // Store auto-start setting for later use - be very explicit
                        this.shouldAutoStart = settings.autoStart === true || settings.autoStart === 'true';
                        console.log('shouldAutoStart set to:', this.shouldAutoStart);
                    } catch (error) {
                        console.error('Failed to load settings:', error);
                        // Ensure defaults when settings fail to load
                        this.shouldAutoStart = false;
                        this.autostartToggle.checked = false;
                        console.log('Settings load failed - shouldAutoStart forced to false');
                        if (this.initializationComplete) {
                            this.addLogEntry({ message: 'Failed to load settings', level: 'error' });
                        }
                    }
                }
                this.toggleBtn.disabled = false;
            }

            async saveSettings() {
                const newPort = parseInt(this.portInput.value);
                
                if (newPort < 1024 || newPort > 65535) {
                    this.addLogEntry({ message: 'Port must be between 1024 and 65535', level: 'error' });
                    this.portInput.value = this.currentPort;
                    return;
                }

                const newSettings = {
                    port: newPort,
                    logLevel: 'info',
                    autoStart: this.autostartToggle.checked,
                    openBrowserOnStart: this.browserToggle.checked
                };
                
                console.log('Saving settings:', newSettings);

                if (window.electronAPI) {
                    try {
                        await window.electronAPI.saveSettings(newSettings);
                        this.currentPort = newPort;
                        this.updateServerUrl();
                        this.addLogEntry({ message: `Settings saved - Port: ${newPort}, Browser Auto-open: ${this.browserToggle.checked ? 'On' : 'Off'}, Auto-start: ${this.autostartToggle.checked ? 'On' : 'Off'}`, level: 'info' });
                    } catch (error) {
                        console.error('Failed to save settings:', error);
                        this.addLogEntry({ message: 'Failed to save settings', level: 'error' });
                        this.portInput.value = this.currentPort;
                    }
                }
            }

            async toggleServer() {
                if (this.serverRunning) {
                    await this.stopServer();
                } else {
                    await this.startServer();
                }
            }

            async startServer() {
                if (window.electronAPI) {
                    try {
                        this.toggleBtn.disabled = true;
                        this.toggleBtn.classList.add('disabled');
                        this.toggleBtnText.textContent = 'Starting...';
                        this.updateStatus('starting', 'Server Starting...');
                        this.addLogEntry({ message: 'Starting server...', level: 'info' });

                        const result = await window.electronAPI.startServer();
                        if (result.success) {
                            this.addLogEntry({ message: 'Server started successfully', level: 'info' });
                        } else {
                            this.addLogEntry({ message: `Failed to start server: ${result.error}`, level: 'error' });
                            this.updateStatus('stopped', 'Server Stopped');
                        }
                    } catch (error) {
                        this.addLogEntry({ message: `Error starting server: ${error.message}`, level: 'error' });
                        this.updateStatus('stopped', 'Server Stopped');
                    } finally {
                        this.toggleBtn.disabled = false;
                        this.toggleBtn.classList.remove('disabled');
                    }
                }
            }

            async stopServer() {
                if (window.electronAPI) {
                    try {
                        this.toggleBtn.disabled = true;
                        this.toggleBtn.classList.add('disabled');
                        this.toggleBtnText.textContent = 'Stopping...';
                        this.addLogEntry({ message: 'Stopping server...', level: 'info' });
                        
                        const result = await window.electronAPI.stopServer();
                        if (result.success) {
                            this.addLogEntry({ message: 'Server stopped', level: 'info' });
                        } else {
                            this.addLogEntry({ message: `Failed to stop server: ${result.error}`, level: 'error' });
                        }
                    } catch (error) {
                        this.addLogEntry({ message: `Error stopping server: ${error.message}`, level: 'error' });
                    } finally {
                        this.toggleBtn.disabled = false;
                        this.toggleBtn.classList.remove('disabled');
                    }
                }
            }

            async openWebInterface() {
                if (window.electronAPI) {
                    try {
                        await window.electronAPI.openWebInterface();
                    } catch (error) {
                        this.addLogEntry({ message: `Error opening web interface: ${error.message}`, level: 'error' });
                    }
                }
            }

            async updateServerStatus() {
                if (window.electronAPI) {
                    try {
                        const status = await window.electronAPI.getServerStatus();
                        this.handleServerStatusUpdate(status);
                    } catch (error) {
                        console.error('Failed to get server status:', error);
                    }
                }
            }

            handleServerStatusUpdate(status) {
                this.serverRunning = status.running;
                
                if (status.running) {
                    this.updateStatus('running', 'Server Running');
                    this.toggleBtnText.textContent = 'Stop Server';
                    this.toggleBtn.classList.remove('btn-gradient-primary');
                    this.toggleBtn.classList.add('btn-gradient-danger');
                    this.webInterfaceSection.classList.remove('hidden');
                } else {
                    this.updateStatus('stopped', 'Server Stopped');
                    this.toggleBtnText.textContent = 'Start Server';
                    this.toggleBtn.classList.remove('btn-gradient-danger');
                    this.toggleBtn.classList.add('btn-gradient-primary');
                    this.webInterfaceSection.classList.add('hidden');
                }

                this.toggleBtn.disabled = false;
                this.toggleBtn.classList.remove('disabled');
                this.updateServerUrl();
            }

            updateStatus(status, text) {
                this.statusIndicator.className = `status-dot status-${status}`;
                this.statusText.textContent = text;
                
                if (status !== 'stopped') {
                    this.logsSection.classList.remove('hidden');
                }
            }

            updateServerUrl() {
                if (this.serverRunning && this.localIP !== 'Loading...') {
                    this.serverUrl.textContent = `${this.localIP}:${this.currentPort}`;
                } else {
                    this.serverUrl.textContent = '';
                }
            }

            async getLocalIP() {
                try {
                    if (window.electronAPI) {
                        this.localIP = await window.electronAPI.getLocalIP();
                    } else {
                        this.localIP = '127.0.0.1';
                    }
                    
                    this.localIpDisplay.textContent = this.localIP;
                    this.updateServerUrl();
                } catch (error) {
                    console.error('Failed to get local IP:', error);
                    this.localIP = '127.0.0.1';
                    this.localIpDisplay.textContent = this.localIP;
                    this.updateServerUrl();
                }
            }

            async refreshLocalIP() {
                this.refreshIpBtn.disabled = true;
                this.refreshIpBtn.textContent = 'â†» Refreshing...';
                this.localIpDisplay.textContent = 'Refreshing...';
                
                try {
                    if (window.electronAPI) {
                        this.localIP = await window.electronAPI.refreshLocalIP();
                        this.localIpDisplay.textContent = this.localIP;
                        this.updateServerUrl();
                        this.addLogEntry({ message: `IP address refreshed: ${this.localIP}`, level: 'info' });
                    }
                } catch (error) {
                    console.error('Failed to refresh local IP:', error);
                    this.addLogEntry({ message: 'Failed to refresh IP address', level: 'error' });
                    this.localIpDisplay.textContent = this.localIP;
                } finally {
                    this.refreshIpBtn.disabled = false;
                    this.refreshIpBtn.textContent = 'â†» Refresh';
                }
            }

            addLogEntry(logData) {
                const timestamp = new Date().toLocaleTimeString();
                const logLine = `${timestamp}: ${logData.message}\n`;
                
                // Add the new log entry
                this.statusLog.value += logLine;
                
                // Keep only last 20 log entries
                const lines = this.statusLog.value.split('\n');
                if (lines.length > 21) { // 21 because last line is often empty
                    this.statusLog.value = lines.slice(-20).join('\n');
                }
                
                // Scroll to bottom
                this.statusLog.scrollTop = this.statusLog.scrollHeight;

                this.logsSection.classList.remove('hidden');
            }
        }

        // Initialize the launcher when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing launcher...');
            try {
                new QOnCommandLauncher();
                console.log('Launcher initialized successfully');
            } catch (error) {
                console.error('Failed to initialize launcher:', error);
            }
        });
    </script>
</body>
</html>